// Registres usuels
SP EQU R15
WR EQU R14
BP EQU R13
// Trappes usuelles
EXIT_EXC EQU 64
READ_EXC EQU 65
WRITE_EXC EQU 66
// Definitions de la valeur NULL
NUL EQU 0
NULL EQU 0
NIL EQU 0
// Adresse debut de la pile
STACK_ADDRS EQU 0x1000
// Adresse debut de programme
LOAD_ADDRS EQU 0xF000
ORG LOAD_ADDRS
START IN_
LDW SP, #STACK_ADDRS
LDW BP, #NIL
print_     
LDQ 0, R1
STW BP, -(SP)
LDW BP, SP
SUB SP, R1, SP
LDW R0, (BP)4
TRP #WRITE_EXC
LDW SP, BP
LDW BP, (SP)+
RTS 
printi_
STW BP, -(SP)
LDW BP, SP
ADI SP, SP, #-8
ADI SP, SP, #-2
LDW R0, (BP)4
STW R0, (BP)-10
LDW R0, #10
STW R0, -(SP)
ADI BP, R0, #-8
STW R0, -(SP)
LDW R0, (BP)-10
STW R0, -(SP)
JSR @itoa_
ADI SP, SP, #6
ADI BP, R0, #-8
STW R0, -(SP)
JSR @print_
ADI SP, SP, #2
LDW SP, BP
LDW BP, (SP)+
RTS
ITOA_I      equ 4      // offset du paramC(tre i
ITOA_P      equ 6      // offset du paramC(tre p
ITOA_B      equ 8      // offset du paramC(tre b
ASCII_MINUS equ 45     // code ASCII de -
ASCII_PLUS  equ 43     // code ASCII de +
ASCII_SP    equ 32     // code ASCII d'eSPace SP
ASCII_0     equ 48     // code ASCII de zC)ro (les autres chiffres jusqu'C  9 suivent dans l'ordre)
ASCII_A     equ 65     // code ASCII de A (les autres lettres jusqu'C  Z suivent dans l'ordre alphabC)tique)
itoa_
stw BP, -(SP)
ldw BP, SP
// rC)cupC)ration des paramC(tres depuis pile vers registres
ldw r0, (BP)ITOA_I    // r0 = i    
ldw r1, (BP)ITOA_B    // r1 = b
// gC(re le signe: normalement itoa gC(re des int c'est C  dire des entiers signC)s, 
// mais en fait seulement pour b=10;
// dans ce cas calcule le signe dans r3 et charge r0 avec la valeur absolue de i
ldq ASCII_SP, r3      // code ASCII de eSPace (SPace) -> r3
ldq 10, WR            // 10 -> WR
cmp r1, WR            // charge les indicateurs de b - 10
bne NOSIGN-$-2        // si non C)gal (donc si b != 10) saute en NOSIGN, sinon calcule signe
ldq ASCII_PLUS, r3    // charge le code ASCII du signe plus + dans r3
tst r0                // charge les indicateurs de r0 et donc de i
bge POSIT-$-2         // saute en POSIT si i >= 0
neg r0, r0            // change le signe de r0
ldq ASCII_MINUS, r3   // charge le code ASCII du signe moins - dans r3
POSIT   NOP                   // r3 = code ASCII de signe: SP pour aucun, - ou +

// convertit l'entier i en chiffres et les empile de droite C  gauche
NOSIGN  ldw r2, r0            // r2 <- r0
CNVLOOP ldw r0, r2            // r0 <- r2
// effectue "crC)ativement" la division par b supposC) pair (car l'instruction div est hC)las signC)e ...)
// d=2*d' , D = d * q + r  , D = 2*D'+r" , D' = d' * q + r' => r = 2*r'+r"
// un bug apparaC.t avec SRL r0, r0 avec r0 = 2 : met CF C  1 !!
srl r1, r1            // r1 = b/2
ani r0, r4, #1        // ANd ImmC)diate entre r0 et 00...01 vers r4:
				  // bit nB00 de r0 -> r4; r4 = reste" de r0/2
srl r0, r0            // r0 / 2 -> r0
div r0, r1, r2        // quotient = r0 / r1 -> r2, reste' = r0 % r1 -> r0
shl r0, r0            // r0 = 2 * reste'
add r0, r4, r0        // r0 = reste = 2 * reste' + reste" => r0 = chiffre
shl r1, r1            // r1 = b

adq -10, r0           // chiffre - 10 -> r0 
bge LETTER-$-2        // saute en LETTER si chiffre >= 10
adq 10+ASCII_0, r0    // ajoute 10 => r0 = chiffre, ajoute code ASCII de 0 
				  // => r0 = code ASCII de chiffre
bmp STKCHR-$-2        // saute en STKCHR 
LETTER  adq ASCII_A, r0       // r0 = ASCII(A) pour chiffre = 10, ASCII(B) pour 11 ...
				  // ajoute code ASCII de A => r = code ASCII de chiffre
STKCHR  stw r0, -(SP)         // empile code ASCII du chiffre 
				  // (sur un mot complet pour pas dC)saligner pile)
tst r2                // charge les indicateurs en fonction du quotient ds r2)
bne CNVLOOP-$-2       // boucle si quotient non nul; sinon sort
// les caractC(res sont maintenant empilC)s : gauche en haut et droit en bas
// recopie les caractC(res dans le tampon dans le bon ordre: de gauche C  droite
ldw r1, (BP)ITOA_P    // r1 pointe sur le dC)but du tampon dC)jC  allouC) 
stb r3, (r1)+         // copie le signe dans le tampon
CPYLOOP ldw r0, (SP)+         // dC)pile code du chiffre gauche (sur un mot) dans r0
stb r0, (r1)+         // copie code du chiffre dans un Byte du tampon de gauche C  droite
cmp SP, BP            // compare SP et sa valeur avant empilement des caractC(res qui C)tait BP
bne CPYLOOP-$-2       // boucle s'il reste au moins un chiffre sur la pile
ldq 10, r0
stb r0, (r1)+
ldq NUL, r0           // charge le code du caractC(re NUL dans r0
stb r0, (r1)+         // sauve code NUL pour terminer la chaC.ne de caractC(res
// termine
ldw r0, (BP)ITOA_P    // retourne le pointeur sur la chaC.ne de caractC(res
// UNLINK: fermeture de l'environnement de la fonction itoa
ldw SP, BP            // SP <- BP : abandonne infos locales; SP pointe sur ancinne valeur de BP
ldw BP, (SP)+         // dC)pile ancienne valeur de BP dans BP; SP pointe sur adresse de retour
rts                   // retourne au programme appelant
ADI SP, SP , #24
IN_
// Ouverture de l'environnement
STW BP, -(SP)
LDW BP, SP
// Reservation sur la pile des variables
LDQ 24, R0
SUB SP, R0, SP
// aa[0,0]:=1;
LDQ 1, R1
STW R1, (BP)-24
// aa[0,1]:=2;
LDQ 2, R1
STW R1, (BP)-22
// aa[0,2]:=3;
LDQ 3, R1
STW R1, (BP)-20
// aa[1,0]:=4;
LDQ 4, R1
STW R1, (BP)-18
// aa[1,1]:=5;
LDQ 5, R1
STW R1, (BP)-16
// aa[1,2]:=5;
LDQ 5, R1
STW R1, (BP)-14
// aa[2,0]:=7;
LDQ 7, R1
STW R1, (BP)-12
// aa[2,1]:=8;
LDQ 8, R1
STW R1, (BP)-10
// aa[2,2]:=9;
LDQ 9, R1
STW R1, (BP)-8
// n:=aa[0,0];
LDW R1, (BP)-24
STW R1, (BP)-2
// i:=aa[1,0];
LDW R1, (BP)-18
STW R1, (BP)-4
// j:=aa[2,0];
LDW R1, (BP)-12
STW R1, (BP)-6
// outinteger(1,n);
LDW R1, (BP)-2
STW R1, -(SP)
JSR @printi_
ADI SP, SP, #2
// outinteger(1,i);
LDW R1, (BP)-4
STW R1, -(SP)
JSR @printi_
ADI SP, SP, #2
// outinteger(1,j)
LDW R1, (BP)-6
STW R1, -(SP)
JSR @printi_
ADI SP, SP, #2
// Fermeture de l'environnement
LDW SP, BP
LDW BP, (SP)+
TRP #EXIT_EXC
JEA @IN_
