// Registres usuels
SP EQU R15
WR EQU R14
BP EQU R13
// Trappes usuelles
EXIT_EXC EQU 64
READ_EXC EQU 65
WRITE_EXC EQU 66
// Definitions de la valeur NULL
NUL EQU 0
NULL EQU 0
NIL EQU 0
// Adresse debut de la pile
STACK_ADDRS EQU 0x1000
// Adresse debut de programme
LOAD_ADDRS EQU 0xF000
ORG LOAD_ADDRS
START IN_
LDW SP, #STACK_ADDRS
LDW BP, #NIL
print_     
LDQ 0, R1
STW BP, -(SP)
LDW BP, SP
SUB SP, R1, SP
LDW R0, (BP)4
TRP #WRITE_EXC
LDW SP, BP
LDW BP, (SP)+
RTS 
printi_
STW BP, -(SP)
LDW BP, SP
ADI SP, SP, #-8
ADI SP, SP, #-2
LDW R0, (BP)4
STW R0, (BP)-10
LDW R0, #10
STW R0, -(SP)
ADI BP, R0, #-8
STW R0, -(SP)
LDW R0, (BP)-10
STW R0, -(SP)
JSR @itoa_
ADI SP, SP, #6
ADI BP, R0, #-8
STW R0, -(SP)
JSR @print_
ADI SP, SP, #2
LDW SP, BP
LDW BP, (SP)+
RTS
ITOA_I      equ 4      // offset du paramC(tre i
ITOA_P      equ 6      // offset du paramC(tre p
ITOA_B      equ 8      // offset du paramC(tre b
ASCII_MINUS equ 45     // code ASCII de -
ASCII_PLUS  equ 43     // code ASCII de +
ASCII_SP    equ 32     // code ASCII d'eSPace SP
ASCII_0     equ 48     // code ASCII de zC)ro (les autres chiffres jusqu'C  9 suivent dans l'ordre)
ASCII_A     equ 65     // code ASCII de A (les autres lettres jusqu'C  Z suivent dans l'ordre alphabC)tique)
itoa_
stw BP, -(SP)
ldw BP, SP
// rC)cupC)ration des paramC(tres depuis pile vers registres
ldw r0, (BP)ITOA_I    // r0 = i    
ldw r1, (BP)ITOA_B    // r1 = b
// gC(re le signe: normalement itoa gC(re des int c'est C  dire des entiers signC)s, 
// mais en fait seulement pour b=10;
// dans ce cas calcule le signe dans r3 et charge r0 avec la valeur absolue de i
ldq ASCII_SP, r3      // code ASCII de eSPace (SPace) -> r3
ldq 10, WR            // 10 -> WR
cmp r1, WR            // charge les indicateurs de b - 10
bne NOSIGN-$-2        // si non C)gal (donc si b != 10) saute en NOSIGN, sinon calcule signe
ldq ASCII_PLUS, r3    // charge le code ASCII du signe plus + dans r3
tst r0                // charge les indicateurs de r0 et donc de i
bge POSIT-$-2         // saute en POSIT si i >= 0
neg r0, r0            // change le signe de r0
ldq ASCII_MINUS, r3   // charge le code ASCII du signe moins - dans r3
POSIT   NOP                   // r3 = code ASCII de signe: SP pour aucun, - ou +

// convertit l'entier i en chiffres et les empile de droite C  gauche
NOSIGN  ldw r2, r0            // r2 <- r0
CNVLOOP ldw r0, r2            // r0 <- r2
// effectue "crC)ativement" la division par b supposC) pair (car l'instruction div est hC)las signC)e ...)
// d=2*d' , D = d * q + r  , D = 2*D'+r" , D' = d' * q + r' => r = 2*r'+r"
// un bug apparaC.t avec SRL r0, r0 avec r0 = 2 : met CF C  1 !!
srl r1, r1            // r1 = b/2
ani r0, r4, #1        // ANd ImmC)diate entre r0 et 00...01 vers r4:
				  // bit nB00 de r0 -> r4; r4 = reste" de r0/2
srl r0, r0            // r0 / 2 -> r0
div r0, r1, r2        // quotient = r0 / r1 -> r2, reste' = r0 % r1 -> r0
shl r0, r0            // r0 = 2 * reste'
add r0, r4, r0        // r0 = reste = 2 * reste' + reste" => r0 = chiffre
shl r1, r1            // r1 = b

adq -10, r0           // chiffre - 10 -> r0 
bge LETTER-$-2        // saute en LETTER si chiffre >= 10
adq 10+ASCII_0, r0    // ajoute 10 => r0 = chiffre, ajoute code ASCII de 0 
				  // => r0 = code ASCII de chiffre
bmp STKCHR-$-2        // saute en STKCHR 
LETTER  adq ASCII_A, r0       // r0 = ASCII(A) pour chiffre = 10, ASCII(B) pour 11 ...
				  // ajoute code ASCII de A => r = code ASCII de chiffre
STKCHR  stw r0, -(SP)         // empile code ASCII du chiffre 
				  // (sur un mot complet pour pas dC)saligner pile)
tst r2                // charge les indicateurs en fonction du quotient ds r2)
bne CNVLOOP-$-2       // boucle si quotient non nul; sinon sort
// les caractC(res sont maintenant empilC)s : gauche en haut et droit en bas
// recopie les caractC(res dans le tampon dans le bon ordre: de gauche C  droite
ldw r1, (BP)ITOA_P    // r1 pointe sur le dC)but du tampon dC)jC  allouC) 
stb r3, (r1)+         // copie le signe dans le tampon
CPYLOOP ldw r0, (SP)+         // dC)pile code du chiffre gauche (sur un mot) dans r0
stb r0, (r1)+         // copie code du chiffre dans un Byte du tampon de gauche C  droite
cmp SP, BP            // compare SP et sa valeur avant empilement des caractC(res qui C)tait BP
bne CPYLOOP-$-2       // boucle s'il reste au moins un chiffre sur la pile
ldq 10, r0
stb r0, (r1)+
ldq NUL, r0           // charge le code du caractC(re NUL dans r0
stb r0, (r1)+         // sauve code NUL pour terminer la chaC.ne de caractC(res
// termine
ldw r0, (BP)ITOA_P    // retourne le pointeur sur la chaC.ne de caractC(res
// UNLINK: fermeture de l'environnement de la fonction itoa
ldw SP, BP            // SP <- BP : abandonne infos locales; SP pointe sur ancinne valeur de BP
ldw BP, (SP)+         // dC)pile ancienne valeur de BP dans BP; SP pointe sur adresse de retour
rts                   // retourne au programme appelant
SELECT_
// Ouverture de l'environnement
STW BP, -(SP)
LDW BP, SP
// Reservation sur la pile des variables
LDQ 0, R0
SUB SP, R0, SP
// M :=N+1;
LDW R0, (BP)4
LDQ 1, R1
ADD R0, R1, R0
STW R0, (BP)6
// outinteger(1,M)
LDW R0, (BP)6
STW R0, -(SP)
JSR @printi_
ADI SP, SP, #2
SELECT_end
// Fermeture de l'environnement
LDW SP, BP
LDW BP, (SP)+
RTS
IN_
// Ouverture de l'environnement
STW BP, -(SP)
LDW BP, SP
// Reservation sur la pile des variables
LDQ 14, R0
SUB SP, R0, SP
// L:=12;
LDQ 12, R1
STW R1, (BP)-2
// i:=1;
LDQ 1, R1
STW R1, (BP)-4
// j:=2;
LDQ 2, R1
STW R1, (BP)-6
//Appel de la fonction : SELECT
//Gestion des potentiels paramC(tres
LDW R1, (BP)-6
STW R1, -(SP)       //On empile les paramC(tres de la fonction appelC)e
LDW R1, (BP)-4
STW R1, -(SP)       //On empile les paramC(tres de la fonction appelC)e
LDW R1, (BP)-2
STW R1, -(SP)       //On empile les paramC(tres de la fonction appelC)e
JSR @SELECT_          //on appelle la fonction C  l'aide de son adresse
ADQ 2*2, SP
// FOR j := 1 STEP 1 UNTIL 5 DO
LDQ 1, R1
STW R1, (BP)-6
begin_cond_For728890494
LDW R1, (BP)-6
LDQ 5, R2
CMP R1, R2
BGT end_cond_For728890494-$-2
// outinteger(1,L);
LDW R1, (BP)-2
STW R1, -(SP)
JSR @printi_
ADI SP, SP, #2
begin_cond_if1558600329
LDW R1, (BP)-6
LDQ 3, R2
CMP R1, R2
BGE 4
LDQ 1, R1
BMP 2
LDQ 0, R1
// cond
TST R1
JEQ #end_cond_if1558600329-$-2
//L:=11
LDQ 11, R1
STW R1, (BP)-2
JMP #end_cond_if_if1558600329-$-2
end_cond_if1558600329
end_cond_if_if1558600329
// L:= L+3;
LDW R1, (BP)-2
LDQ 3, R2
ADD R1, R2, R1
STW R1, (BP)-2
begin_cond_if636718812
LDW R1, (BP)-6
LDQ 15, R2
DIV R1, R2, R1
LDQ 1, R2
CMP R1, R2
BNE 4
LDQ 1, R1
BMP 2
LDQ 0, R1
// cond
TST R1
JEQ #end_cond_if636718812-$-2
//i:=2
LDQ 2, R1
STW R1, (BP)-4
JMP #end_cond_if_if636718812-$-2
end_cond_if636718812
end_cond_if_if636718812
// j=j+1
LDW R1, (BP)-6
ADQ 1, R1
STW R1, (BP)-6
BMP begin_cond_For728890494-$-2
end_cond_For728890494
// L:=L*3;
LDW R2, (BP)-2
LDQ 3, R3
MUL R2, R3, R2
STW R2, (BP)-2
// outinteger(1,L);
LDW R2, (BP)-2
STW R2, -(SP)
JSR @printi_
ADI SP, SP, #2
// L:=L+3;
LDW R2, (BP)-2
LDQ 3, R3
ADD R2, R3, R2
STW R2, (BP)-2
// outinteger(1,L);
LDW R2, (BP)-2
STW R2, -(SP)
JSR @printi_
ADI SP, SP, #2
// L:=L-3;
LDW R2, (BP)-2
LDQ 3, R3
SUB R2, R3, R2
STW R2, (BP)-2
// outinteger(1,L);
LDW R2, (BP)-2
STW R2, -(SP)
JSR @printi_
ADI SP, SP, #2
// L:=L/2;
LDW R2, (BP)-2
LDQ 2, R3
DIV R2, R3, R2
STW R2, (BP)-2
// outinteger(1,L);
LDW R2, (BP)-2
STW R2, -(SP)
JSR @printi_
ADI SP, SP, #2
// outinteger(1,i)
LDW R2, (BP)-4
STW R2, -(SP)
JSR @printi_
ADI SP, SP, #2
// Fermeture de l'environnement
LDW SP, BP
LDW BP, (SP)+
TRP #EXIT_EXC
JEA @IN_
